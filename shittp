#!/bin/sh

set -eu

: ${SHITTP_CONFIG_DIR:="${XDG_CONFIG_HOME:-$HOME/.config}/shittp"}

cleanup() {
  [ "${tar_tmpdir:-}" ] && rm -r "$tar_tmpdir"
}

# Do not trap any signal when running shellspec test
[ "${__SOURCED__:-}" ] || trap cleanup EXIT

msg() {
  IFS=" $IFS"
  set -- '%s\n' "${*:-}"
  IFS=${IFS#?}
  printf "$@"
}

die() {
  [ "${1:-}" ] && msg "$1"
  exit "${2:-1}"
}

require() {
  _status=0
  while [ $# -gt 0 ]; do
    type "$1" >/dev/null 2>&1 || {
      msg "Dependency [ $1 ] is required";
      _status=1
    }
    shift
  done
  return "$_status"
}

usage() {
  cat <<'USAGE'
shittp - dotfiles carrier for SSH

Usage: shittp [options]... [command] [ssh_options]... destination

Options:
  -h, --help            You're looking at it
  --config-dir DIR      Specify shittp config directory [default: ~/.config/shittp]

Commands:
  where                 Show default shittp config directory
  print                 Print the command instead of run as SSH remote command
                        Useful when you want to run in different environment like Docker

Examples:
  shittp john@192.168.78.66  # SSH login to 192.168.78.66 with your dotfiles
  shittp where               # Prints shittp config directory (i.e. ~/.config/shittp)
  sudo docker run -it alpine /bin/sh -c "$(shittp print)"
                             # Start sh in alpine with your dotfiles
USAGE
exit 0
}

cmd_where=0
cmd_print_only=0
parse_args() {
  while [ $# -gt 0 ]; do
    _consumed=0
    case $1 in
      -h | --help)
        usage
      ;;
      where)
        cmd_where=1
        return
      ;;
      print)
        _consumed=1
        cmd_print_only=1
        shift
      ;;
      --config-dir)
        _consumed=1
        [ "${2:-}" ] || die "SHITTP_CONFIG_DIR of option [ $1 ] not specified"
        SHITTP_CONFIG_DIR=$(cd "$2" && pwd -P)
        shift # --config
        shift # SHITTP_CONFIG_DIR
      ;;
      -o)
        case $2 in 
          [Rr]emote[Cc]ommand=*)
            _consumed=1
            extra_command=${2#[Rr]emote[Cc]ommand=}
            shift # -o
            shift # RemoteCommand=XXX
          ;;
        esac
      ;;
      -o[Rr]emote[Cc]ommand=*)
        _consumed=1
        extra_command=${1#[Rr]emote[Cc]ommand=}
        shift # -oRemoteCommand=XXX
      ;;
      *)
      ;;
    esac
    if [ "$_consumed" = 0 ]; then
      if [ "${rest_args:-}" ]; then
        rest_args="$rest_args
$1"
      else
        rest_args="$1"
      fi
      shift
    fi
  done
}

dir_to_b64() {
  tar czf - -C "$1" . |
    base64 |
    while IFS= read -r line; do
      printf '%s' "$line"
    done
}

# Early return for shellspec testing
${__SOURCED__:+return}

# Show help if no arguments provided
[ $# -eq 0 ] && usage

parse_args "$@"
set --
while IFS= read -r line; do
  set -- "$@" "$line"
done <<< "${rest_args:-}" # Bug: pass multi-line as single arg will incorrectly parsed as several args

if [ "$cmd_where" = 1 ]; then
  echo "$SHITTP_CONFIG_DIR"
  exit 0
fi

require mktemp tar base64

if [ ! -d "$SHITTP_CONFIG_DIR" ]; then
  die "Config [ $SHITTP_CONFIG_DIR ] is required"
fi

tar_tmpdir=$(mktemp --directory)
cp -r "$SHITTP_CONFIG_DIR" "$tar_tmpdir/shittp"

# Create the script with here-document so we don't need to figure out how to escape quotes
setup_script=$(cat <<'SETUP'
trap 'rm -rf "$SHITTP_HOME"' EXIT

export SHITTP="$SHITTP_HOME/shittp_init.sh"
echo "echo '[shittp] Inited'" >>"$SHITTP" # ensure exists

case $SHELL in
  *bash*)
    echo '. "$SHITTP"' >>"$SHITTP_HOME/.bashrc"
    bash --init-file "$SHITTP_HOME/.bashrc"
  ;;
  *zsh*)
    echo '. "$SHITTP"' >>"$SHITTP_HOME/.zshrc"
    export ZDOTDIR=$SHITTP_HOME
    zsh -i
  ;;
  *) 
    echo '[shittp] Run this to initialize:'
    echo '. "$SHITTP"'
    ${SHELL:-/bin/sh} -i
  ;;
esac
SETUP
)

remote_command='archive="'"$(dir_to_b64 "$tar_tmpdir/shittp")"'"''
tmpdir=$(mktemp --directory)
printf "$archive" | base64 -d | tar zxf - -C "$tmpdir"
export SHITTP_HOME=$tmpdir
# shittp_setup
'"$setup_script"'
# extra command
'"${extra_command:-}"

if [ "$cmd_print_only" = 1 ]; then
  msg "$remote_command"
else
  ssh -t -o RemoteCommand="$remote_command" "$@"
fi

